---
title: "Chapter 02. Small Worlds and Large Worlds"
author: "A Solomon Kurz"
date: "`r format(Sys.Date())`"
output:
  github_document
---

```{r, echo = F, cache = F}
knitr::opts_chunk$set(fig.retina = 2.5)
knitr::opts_chunk$set(fig.align = "center")
library(ggformula)
theme_set(theme_bw())
options(width = 100)
use_ggformula <- TRUE
```

## Some Notes on Coding Style before we begin: Four C's

Computer code simultaneously communicates both to humans and to the computer.
Not all code that works is equally good. Here are 4 C's to consider as you write
your code.

* **Correctness:** It is important that the code be **correct** so that the computer does what you intend.

* **Clarity:** But it is also important the that code be **clear**, so that humans reading and writing
the code can tell what it is intended to do, and easily make modifications as necessary.

* **Containment:** It is also helpful if the code is appropriately **contained**, 
to keep separate things that should be separate and together things that should be together.

* **Consistency:** Finally, it is useful if your code exhibits internal
**consistency** of style and naming conventions. There are several competing
style guides for R. We will adopt a style guide patterned after that used by the authors
of the **tidyverse** suite of packages.

The code presented in McElreath's *Statistical Rethinking* does OK at being correct,
it isn't as clear as it could be, does very poorly at containment, and adopts a style
that is prone to errors.  Particular features of that code to avoid:

* Renaming every data set `d`. 

    It is hard to imagine why this was considered a good idea. It does not communicate well to humans
    and it is very easy to have a different data set than the one you intend if they are all named
    the same thing.  *Don't do this!*
    
* Using lots of "loose vectors".

    R allows us to put vectors into lists or data frames, and the **tidyverse** provides nice functions
    for working with them inside those containers. Furthermore, **ggformula** works best when the 
    data being plotted is in a data frame.
    
* Using "base R" functions.

    This is more a matter of opinion and style, but there are many newer packages that make coding
    easier and clearer. This will impact you most if you start googling for code. Make sure you
    find code that is in the same style as what is domenstrated here -- don't create Frankencode with
    odd bits cobbled together from very different coding styles.
    
# Small Worlds and Large Worlds

A while back The Oatmeal put together an [infographic on Christopher Columbus](http://theoatmeal.com/comics/columbus_day). I'm no historian and cannot vouch for its accuracy, so make of it what you will.

McElreath described the thrust of this chapter this way:

> In this chapter, you will begin to build Bayesian models. The way that Bayesian models learn from evidence is arguably optimal in the small world. When their assumptions approximate reality, they also perform well in the large world. But large world performance has to be demonstrated rather than logically deduced. [@mcelreathStatisticalRethinkingBayesian2020, p. 20]

Indeed.

## The garden of forking data

Gelman and Loken [-@gelmanGardenForkingPaths2013] wrote a [great paper of a similar name](https://stat.columbia.edu/~gelman/research/unpublished/p_hacking.pdf) and topic. The titles from this section and Gelman and Loken's paper have their origins in the short story by [Jorge Luis Borges](https://en.wikipedia.org/wiki/Jorge_Luis_Borges) [-@borgesjlJardinSenderosQue1941], *The garden of forking paths*. You can find copies of the original short story [here](https://archive.org/stream/TheGardenOfForkingPathsJorgeLuisBorges1941/The-Garden-of-Forking-Paths-Jorge-Luis-Borges-1941_djvu.txt) or [here](https://genius.com/Jorge-luis-borges-the-garden-of-forking-paths-annotated). Here's a snip:

> In all fictional works, each time a man is confronted with several alternatives, he chooses one and eliminates the others; in the fiction of Ts'ui PÃªn, he chooses--simultaneously--all of them. He creates, in this way, diverse futures, diverse times which themselves also proliferate and fork.

The choices we make in our data analyses proliferate and fork in this way, too.

### Counting possibilities.

Throughout this project, we'll make extensive use packages from the [**tidyverse**](https://www.tidyverse.org) for data wrangling and plotting.

```{r, warning = F, message = F}
library(tidyverse)
```

If you are new to **tidyverse**-style syntax, possibly the oddest component is the pipe (i.e., `%>%`). I'm not going to explain the `%>%` in this project, but you might learn more about in [this brief clip](https://www.youtube.com/watch?v=9yjhxvu-pDg), starting around [minute 21:25 in this talk by Wickham](https://www.youtube.com/watch?v=K-ss_ag2k9E&t=1285s), or in [Section 5.6.1](https://r4ds.had.co.nz/transform.html#combining-multiple-operations-with-the-pipe) from Grolemund and Wickham's [-@grolemundDataScience2017] *R for data science*. Really, all of Chapter 5 of *R4DS* is just great for new **R** and new **tidyverse** users. And *R4DS* Chapter 3 is a nice introduction to plotting with **ggplot2** [@R-ggplot2; @wickhamGgplot2ElegantGraphics2016].

Other than the pipe, the other big thing to be aware of is [tibbles](https://tibble.tidyverse.org) [@R-tibble]. For our purposes, think of a tibble as a data object with two dimensions defined by rows and columns. Importantly, tibbles are just special types of [data frames](https://bookdown.org/rdpeng/rprogdatascience/r-nuts-and-bolts.html#data-framesbookdown::preview_chapter("06.Rmd")). So, whenever we talk about data frames, we're usually talking about tibbles. For more on the topic, check out [*R4SD*, Chapter 10](https://r4ds.had.co.nz/tibbles.html).

If we're willing to code the marbles as 0 = "white" 1 = "blue", we can arrange the possibility data in a tibble as follows.

```{r, warning = F, message = F}
Possibilities <-
  tibble(p1 = 0,
         p2 = rep(1:0, times = c(1, 3)),
         p3 = rep(1:0, times = c(2, 2)),
         p4 = rep(1:0, times = c(3, 1)),
         p5 = 1)

Possibilities
```

You might depict the possibility data in a plot.

```{r, fig.width = 1.25, fig.height = 1.1, include = !use_ggformula, eval = !use_ggformula}
Possibilities %>% 
  set_names(1:5) %>% 
  mutate(x = 1:4) %>% 
  pivot_longer(-x, names_to = "possibility") %>% 
  mutate(value = value %>% as.character()) %>% 
  
  ggplot(aes(x = x, y = possibility, fill = value)) +
  geom_point(shape = 21, size = 5) +
  scale_fill_manual(values = c("white", "navy")) +
  scale_x_discrete(NULL, breaks = NULL) +
  theme(legend.position = "none")
```

```{r, fig.width = 1.25, fig.height = 1.1, include = use_ggformula, eval = use_ggformula}
Possibilities %>% 
  set_names(1:5) %>% 
  mutate(x = 1:4) %>% 
  pivot_longer(-x, names_to = "possibility") %>% 
  mutate(value = value %>% as.character()) %>% 
  gf_point(possibility ~ x, fill = ~value, shape = 21, size = 5) %>%
  gf_refine(
    scale_fill_manual(values = c("white", "navy")),
    scale_x_discrete(NULL, breaks = NULL)) %>%
  gf_theme(legend.position = "none")
```

As a quick aside, check out Suzan Baert's blog post [*Data wrangling part 2: Transforming your columns into the right shape*](https://suzan.rbind.io/2018/02/dplyr-tutorial-2/) for an extensive discussion on `dplyr::mutate()` and `tidyr::gather()`. The `tidyr::pivot_longer()` function is an updated variant of `gather()`, which we'll be making extensive use of throughout this project. If you're new to reshaping data with pivoting, check out the vignettes [here](https://tidyr.tidyverse.org/reference/pivot_longer.html) and [here](https://tidyr.tidyverse.org/articles/pivot.html) [@PivotDataWide2020; @Pivoting2020].

Here's the basic structure of the possibilities per marble draw.

```{r}
tibble(
  draw    = 1:3,
  marbles = 4) %>% 
  mutate(possibilities = marbles ^ draw) %>% 
  knitr::kable()
```

If you walk that out a little, you can structure the data required to approach Figure 2.2.

```{r}
(
  Garden <-
    tibble(position = c((1:4^1) / 4^0, 
                        (1:4^2) / 4^1, 
                        (1:4^3) / 4^2),
           draw     = rep(1:3, times = c(4^1, 4^2, 4^3)),
           fill     = rep(c("b", "w"), times = c(1, 3)) %>% 
             rep(., times = c(4^0 + 4^1 + 4^2)))
)
```

See what I did there with the parentheses? If you assign a value to an object in **R** (e.g., `dog <- 1`) and just hit return, nothing will immediately pop up in the [console](http://r4ds.had.co.nz/introduction.html#rstudio). You have to actually execute `dog` before **R** will return `1`. But if you wrap the code within parentheses (e.g., `(dog <- 1)`), **R** will perform the assignment and return the value as if you had executed `dog`.

But we digress. Here's the initial plot.

```{r, fig.width = 8, fig.height = 2, include = !use_ggformula, eval = !use_ggformula}
Garden %>% 
  ggplot(aes(x = position, y = draw, fill = fill)) +
  geom_point(shape = 21, size = 3) +
  scale_fill_manual(values  = c("navy", "white")) +
  scale_y_continuous(breaks = 1:3) +
  theme(legend.position = "none",
        panel.grid.minor = element_blank())
```

```{r, fig.width = 8, fig.height = 2, include = use_ggformula, eval = use_ggformula}
Garden %>% 
  gf_point(draw ~ position, fill = ~ fill, shape = 21, size = 3) %>%
  gf_refine(
    scale_fill_manual(values  = c("navy", "white")),
    scale_y_continuous(breaks = 1:3)) %>%
  gf_theme(
    legend.position = "none",
    panel.grid.minor = element_blank())
```

To my mind, the easiest way to connect the dots in the appropriate way is to make two auxiliary tibbles.

```{r}
# these will connect the dots from the first and second draws
(
  Lines_1 <-
    tibble(x    = rep((1:4), each = 4),
           xend = ((1:4^2) / 4),
           y    = 1,
           yend = 2)
)

# these will connect the dots from the second and third draws
(
  Lines_2 <-
    tibble(x    = rep(((1:4^2) / 4), each = 4),
           xend = (1:4^3) / (4^2),
           y    = 2,
           yend = 3)
)
```

We can use the `Lines_1` and `Lines_2` data in the plot to draw the line segments.
<!-- with two `geom_segment()` functions. -->

```{r, fig.width = 8, fig.height = 2, include = !use_ggformula, eval = !use_ggformula}
Garden %>% 
  ggplot(aes(x = position, y = draw)) +
  geom_segment(data = Lines_1,
               aes(x = x, xend = xend,
                   y = y, yend = yend),
               size  = 1/3) +
  geom_segment(data = Lines_2,
               aes(x = x, xend = xend,
                   y = y, yend = yend),
               size  = 1/3) +
  geom_point(aes(fill = fill),
             shape = 21, size = 3) +
  scale_fill_manual(values  = c("navy", "white")) +
  scale_y_continuous(breaks = 1:3) +
  theme(legend.position  = "none",
        panel.grid.minor = element_blank())
```

```{r, fig.width = 8, fig.height = 2, include = use_ggformula, eval = use_ggformula}
gf_segment(y + yend ~ x + xend, size = 1/3, data = Lines_1) %>%
  gf_segment(y + yend ~ x + xend, size = 1/3, data = Lines_2) %>%
  gf_point(draw ~ position, fill = ~ fill, shape = 21, size = 3, 
           data = Garden, inherit = FALSE) %>%
  gf_refine(
    scale_fill_manual(values  = c("navy", "white")),
    scale_y_continuous(breaks = 1:3)) %>%
  gf_theme(
    legend.position  = "none", panel.grid.minor = element_blank())
```

We've generated the values for `position` (i.e., the $x$-axis), in such a way that they're all justified to the right, so to speak. But we'd like to center them. For `draw == 1`, we'll need to subtract 0.5 from each. For `draw == 2`, we need to reduce the scale by a factor of 4 and we'll then need to reduce the scale by another factor of 4 for `draw == 3`. The `case_when()` function will be of use for that.

```{r}
Garden <-
  Garden %>% 
  mutate(
    denominator = 
      case_when(
        draw == 1 ~ .5,
        draw == 2 ~ .5 / 4,
        draw == 3 ~ .5 / 4^2),
    position = position - denominator
  ) 

Garden
```

We'll follow the same logic for the `Lines_1` and `Lines_2` data.

```{r}
(
  Lines_1 <-
  Lines_1 %>% 
  mutate(x    = x - 0.5,
         xend = xend - 0.5 / 4^1)
)

(
  Lines_2 <-
  Lines_2 %>% 
  mutate(x    = x - 0.5 / 4^1,
         xend = xend - 0.5 / 4^2)
)
```

Now the plot's looking closer.

```{r, fig.width = 8, fig.height = 2, include = !use_ggformula, eval = !use_ggformula}
Garden %>% 
  ggplot(aes(x = position, y = draw)) +
  geom_segment(data = Lines_1,
               aes(x = x, xend = xend,
                   y = y, yend = yend),
               size  = 1/3) +
  geom_segment(data = Lines_2,
               aes(x = x, xend = xend,
                   y = y, yend = yend),
               size  = 1/3) +
  geom_point(aes(fill = fill),
             shape = 21, size = 3) +
  scale_fill_manual(values  = c("navy", "white")) +
  scale_y_continuous(breaks = 1:3) +
  theme(legend.position  = "none",
        panel.grid.minor = element_blank())
```

```{r, fig.width = 8, fig.height = 2, include = use_ggformula, eval = use_ggformula}
gf_segment(y + yend ~ x + xend, data = Lines_1, size  = 1/3) %>% 
  gf_segment(y + yend ~ x + xend, data = Lines_2, size  = 1/3) %>% 
  gf_point(draw ~ position, fill = ~ fill, data = Garden, inherit = FALSE,
             shape = 21, size = 3) %>%
  gf_refine(
    scale_fill_manual(values  = c("navy", "white")),
    scale_y_continuous(breaks = 1:3)
  ) %>%
  gf_theme(
    legend.position  = "none",
    panel.grid.minor = element_blank())
```

For the final step, we'll use `coord_polar()` to change the [coordinate system](http://sape.inf.usi.ch/quick-reference/ggplot2/coord), giving the plot a mandala-like feel.

```{r, fig.width = 4, fig.height = 4, include = !use_ggformula, eval = !use_ggformula}
Garden %>% 
  ggplot(aes(x = position, y = draw)) +
  geom_segment(data = Lines_1,
               aes(x = x, xend = xend,
                   y = y, yend = yend),
               size = 1/3) +
  geom_segment(data = Lines_2,
               aes(x = x, xend = xend,
                   y = y, yend = yend),
               size = 1/3) +
  geom_point(aes(fill = fill),
             shape = 21, size = 4) +
  scale_fill_manual(values = c("navy", "white")) +
  scale_x_continuous(NULL, limits = c(0, 4), breaks = NULL) +
  scale_y_continuous(NULL, limits = c(0.75, 3), breaks = NULL) +
  coord_polar() +
  theme(legend.position = "none",
        panel.grid = element_blank())
```

```{r, fig.width = 4, fig.height = 4, include = use_ggformula, eval = use_ggformula}
last_plot() %>%
  gf_refine(coord_polar())
```

To make our version of Figure 2.3, we'll have to add an index to tell us which paths remain logically valid after each choice. We'll call the index `remain`.

```{r, fig.width = 4, fig.height = 4, include = !use_ggformula, eval = !use_ggformula}
Lines_1 <-
  Lines_1 %>% 
  mutate(remain = c(rep(0:1, times = c(1, 3)),
                    rep(0,   times = 4 * 3)))
Lines_2 <-
  Lines_2 %>% 
  mutate(remain = c(rep(0,   times = 4),
                    rep(1:0, times = c(1, 3)) %>% rep(., times = 3),
                    rep(0,   times = 12 * 4)))
Garden <-
  Garden %>% 
  mutate(remain = c(rep(1:0, times = c(1, 3)),
                    rep(0:1, times = c(1, 3)),
                    rep(0,   times = 4 * 4),
                    rep(1:0, times = c(1, 3)) %>% rep(., times = 3),
                    rep(0,   times = 12 * 4))) 
# finally, the plot:
Garden %>% 
  ggplot(aes(x = position, y = draw)) +
  geom_segment(data = Lines_1,
               aes(x = x, xend = xend,
                   y = y, yend = yend,
                   alpha = remain %>% as.character()),
               size = 1/3) +
  geom_segment(data = Lines_2,
               aes(x = x, xend = xend,
                   y = y, yend = yend,
                   alpha = remain %>% as.character()),
               size = 1/3) +
  geom_point(aes(fill = fill, alpha = remain %>% as.character()),
             shape = 21, size = 4) +
  # it's the alpha parameter that makes elements semitransparent
  scale_fill_manual(values = c("navy", "white")) +
  scale_alpha_manual(values = c(1/5, 1)) +
  scale_x_continuous(NULL, limits = c(0, 4), breaks = NULL) +
  scale_y_continuous(NULL, limits = c(0.75, 3), breaks = NULL) +
  coord_polar() +
  theme(legend.position = "none",
        panel.grid = element_blank())
```


```{r, fig.width = 4, fig.height = 4, include = use_ggformula, eval = use_ggformula}
Lines_1 <-
  Lines_1 %>% 
  mutate(remain = c(rep(0:1, times = c(1, 3)),
                    rep(0,   times = 4 * 3)))
Lines_2 <-
  Lines_2 %>% 
  mutate(remain = c(rep(0,   times = 4),
                    rep(1:0, times = c(1, 3)) %>% rep(., times = 3),
                    rep(0,   times = 12 * 4)))
Garden <-
  Garden %>% 
  mutate(remain = c(rep(1:0, times = c(1, 3)),
                    rep(0:1, times = c(1, 3)),
                    rep(0,   times = 4 * 4),
                    rep(1:0, times = c(1, 3)) %>% rep(., times = 3),
                    rep(0,   times = 12 * 4))) 
# finally, the plot:
gf_segment(y + yend ~ x + xend, data = Lines_1,
           alpha = ~ as.character(remain), size = 1/3) %>% 
  gf_segment(y + yend ~ x + xend, data = Lines_2,
             alpha = ~ as.character(remain), size = 1/3) %>% 
  gf_point(draw ~ position, data = Garden, inherit = FALSE,
           fill = ~ fill,  alpha = ~ as.character(remain), 
           shape = 21, size = 4) %>%
  # it's the alpha parameter that makes elements semitransparent
  gf_refine(
    scale_fill_manual(values = c("navy", "white")),
    scale_alpha_manual(values = c(1/5, 1)), 
    scale_x_continuous(NULL, limits = c(0, 4), breaks = NULL), 
    scale_y_continuous(NULL, limits = c(0.75, 3), breaks = NULL),
    coord_polar() 
  ) %>%
  gf_theme(legend.position = "none",
           panel.grid = element_blank())
```


Letting "w" = a white dot and "b" = a blue dot, we might recreate the table in the middle of page 23 like so.

```{r}
# if we make two custom functions, here, it will simplify the code within `mutate()`, below
n_blue <- function(x) {
  rowSums(x == "b")
}

n_white <- function(x) {
  rowSums(x == "w")
}

Table23 <-
  # for the first four columns, `p_` indexes position
  tibble(p_1 = rep(c("w", "b"), times = c(1, 4)),
         p_2 = rep(c("w", "b"), times = c(2, 3)),
         p_3 = rep(c("w", "b"), times = c(3, 2)),
         p_4 = rep(c("w", "b"), times = c(4, 1))) %>% 
  mutate(`draw 1: blue`  = n_blue(.),
         `draw 2: white` = n_white(.),
         `draw 3: blue`  = n_blue(.)) %>% 
  mutate(`ways to produce` = `draw 1: blue` * `draw 2: white` * `draw 3: blue`)
Table23 %>% 
  knitr::kable()
```

We'll need new data for Figure 2.4. Here's the initial primary data, `d`.

```{r}
Garden2 <-
  tibble(position = c((1:4^1) / 4^0, 
                      (1:4^2) / 4^1, 
                      (1:4^3) / 4^2),
         draw     = rep(1:3, times = c(4^1, 4^2, 4^3)))

(
  Garden2 <-
  Garden2 %>% 
  bind_rows(
    Garden2, Garden2
  ) %>% 
  # here are the fill colors
  mutate(fill = c(rep(c("w", "b"), times = c(1, 3)) %>% rep(., times = c(4^0 + 4^1 + 4^2)),
                  rep(c("w", "b"), each  = 2)       %>% rep(., times = c(4^0 + 4^1 + 4^2)),
                  rep(c("w", "b"), times = c(3, 1)) %>% rep(., times = c(4^0 + 4^1 + 4^2)))) %>% 
  # now we need to shift the positions over in accordance with draw, like before
  mutate(denominator = ifelse(draw == 1, .5,
                              ifelse(draw == 2, .5 / 4,
                                     .5 / 4^2))) %>% 
  mutate(position = position - denominator) %>% 
  # here we'll add an index for which pie wedge we're working with
  mutate(pie_index = rep(letters[1:3], each = n()/3)) %>% 
  # to get the position axis correct for pie_index == "b" or "c", we'll need to offset
  mutate(position = ifelse(pie_index == "a", position,
                           ifelse(pie_index == "b", position + 4,
                                  position + 4 * 2)))
)
```

Both `Lines_1` and `Lines_2` require adjustments for `x` and `xend`. Our current approach is a nested `ifelse()`. Rather than copy and paste that multi-line `ifelse()` code for all four, let's wrap it in a compact function, which we'll call `move_over()`.

```{r}
move_over <- function(position, index) {
  ifelse(
    index == "a", position,
    ifelse(
      index == "b", position + 4, position + 4 * 2
    )
  )
}
```

If you're new to making your own **R** functions, check out [Chapter 19](http://r4ds.had.co.nz/functions.html) of *R4DS* or [Chapter 14](https://bookdown.org/rdpeng/rprogdatascience/functions.html) of *R programming for data science* [@pengProgrammingDataScience2019].

Anyway, now we'll make our new `Lines_1` and `Lines_2` data, for which we'll use `move_over()` to adjust their `x` and `xend` positions to the correct spots.

```{r}
(
  Lines_1 <-
  tibble(x    = rep((1:4), each = 4) %>% rep(., times = 3),
         xend = ((1:4^2) / 4)        %>% rep(., times = 3),
         y    = 1,
         yend = 2) %>% 
  mutate(x    = x - .5,
         xend = xend - .5 / 4^1) %>% 
  # here we'll add an index for which pie wedge we're working with
  mutate(pie_index = rep(letters[1:3], each = n()/3)) %>% 
  # to get the position axis correct for `pie_index == "b"` or `"c"`, we'll need to offset
  mutate(x    = move_over(position = x,    index = pie_index),
         xend = move_over(position = xend, index = pie_index))
)

(
  Lines_2 <-
  tibble(x    = rep(((1:4^2) / 4), each = 4)  %>% rep(., times = 3),
         xend = (1:4^3 / 4^2)                 %>% rep(., times = 3),
         y    = 2,
         yend = 3) %>% 
  mutate(x    = x - .5 / 4^1,
         xend = xend - .5 / 4^2) %>% 
  # here we'll add an index for which pie wedge we're working with
  mutate(pie_index = rep(letters[1:3], each = n()/3)) %>% 
  # to get the position axis correct for `pie_index == "b"` or `"c"`, we'll need to offset
  mutate(x    = move_over(position = x,    index = pie_index),
         xend = move_over(position = xend, index = pie_index))
)
```

For the last data wrangling step, we add the `remain` indices to help us determine which parts to make semitransparent. I'm not sure of a slick way to do this, so these are the result of brute force counting.

```{r}
Garden2 <- 
  Garden2 %>% 
  mutate(remain = c(#pie_index == "a"
                    rep(0:1, times = c(1, 3)),
                    rep(0,   times = 4),
                    rep(1:0, times = c(1, 3)) %>% rep(., times = 3),
                    rep(0,   times = 4 * 4),
                    rep(c(0, 1, 0), times = c(1, 3, 4 * 3)) %>% rep(., times = 3),
                    # pie_index == "b"
                    rep(0:1, each = 2),
                    rep(0,   times = 4 * 2),
                    rep(1:0, each = 2) %>% rep(., times = 2),
                    rep(0,   times = 4 * 4 * 2),
                    rep(c(0, 1, 0, 1, 0), times = c(2, 2, 2, 2, 8)) %>% rep(., times = 2),
                    # pie_index == "c",
                    rep(0:1, times = c(3, 1)),
                    rep(0,   times = 4 * 3),
                    rep(1:0, times = c(3, 1)), 
                    rep(0,   times = 4 * 4 * 3),
                    rep(0:1, times = c(3, 1)) %>% rep(., times = 3),
                    rep(0,   times = 4)
                    )
         )

Lines_1 <-
  Lines_1 %>% 
  mutate(remain = c(rep(0,   times = 4),
                    rep(1:0, times = c(1, 3)) %>% rep(., times = 3),
                    rep(0,   times = 4 * 2),
                    rep(1:0, each  = 2) %>% rep(., times = 2),
                    rep(0,   times = 4 * 3),
                    rep(1:0, times = c(3, 1))
                    )
         )

Lines_2 <-
  Lines_2 %>% 
  mutate(remain = c(rep(0,   times = 4 * 4),
                    rep(c(0, 1, 0), times = c(1, 3, 4 * 3)) %>% rep(., times = 3),
                    rep(0,   times = 4 * 8),
                    rep(c(0, 1, 0, 1, 0), times = c(2, 2, 2, 2, 8)) %>% rep(., times = 2),
                    rep(0,   times = 4 * 4 * 3),
                    rep(0:1, times = c(3, 1)) %>% rep(., times = 3),
                    rep(0,   times = 4)
                    )
         )
```

We're finally ready to plot our Figure 2.4.

```{r, fig.width = 7, fig.height = 7, include = !use_ggformula, eval = !use_ggformula}
Garden2 %>% 
  ggplot(aes(x = position, y = draw)) +
  geom_vline(xintercept = c(0, 4, 8), color = "white", size = 2/3) +
  geom_segment(data = Lines_1,
               aes(x = x, xend = xend,
                   y = y, yend = yend,
                   alpha = remain %>% as.character()),
               size = 1/3) +
  geom_segment(data = Lines_2,
               aes(x = x, xend = xend,
                   y = y, yend = yend,
                   alpha = remain %>% as.character()),
               size = 1/3) +
  geom_point(aes(fill = fill, size = draw, alpha = remain %>% as.character()),
             shape = 21) +
  scale_fill_manual(values = c("navy", "white")) +
  scale_size_continuous(range = c(3, 1.5)) +
  scale_alpha_manual(values = c(0.2, 1)) +
  scale_x_continuous(NULL, limits = c(0, 12), breaks = NULL) +
  scale_y_continuous(NULL, limits = c(0.75, 3.5), breaks = NULL) +
  coord_polar() +
  theme(legend.position = "none",
        panel.grid = element_blank())
```

```{r, fig.width = 7, fig.height = 7, include = use_ggformula, eval = use_ggformula}
gf_rect(0.75 + 3.5 ~ 0 + 4, fill = "navy", alpha = 0.2, inherit = FALSE) %>%
gf_rect(0.75 + 3.5 ~ 4 + 8, fill = "forestgreen", alpha = 0.2, inherit = FALSE) %>%
gf_rect(0.75 + 3.5 ~ 8 + 12, fill = "red", alpha = 0.2, inherit = FALSE) %>%
# gf_vline(xintercept = ~ c(0, 4, 8), color = "white", size = 2/3, data = NA) %>% 
  gf_segment(y + yend ~ x + xend, data = Lines_1,
             alpha = ~ as.character(remain),  size = 1/3) %>% 
  gf_segment(y + yend ~ x + xend, data = Lines_2,
             alpha = ~ as.character(remain), size = 1/3) %>%
  gf_segment(y + yend ~ x + xend, data = Lines_2,
             alpha = ~ as.character(remain), size = 1/3) %>%
  gf_point(draw ~ position, data = Garden2, inherit = FALSE,
           fill = ~ fill, size = ~ draw, 
           alpha = ~ as.character(remain), shape = 21) %>%
  gf_refine(
    scale_fill_manual(values = c("navy", "white")),
    scale_size_continuous(range = c(3, 1.5)),
    scale_alpha_manual(values = c(0.2, 1)),
    scale_x_continuous(NULL, limits = c(0, 12), breaks = NULL),
    scale_y_continuous(NULL, limits = c(0.5, 3.5), breaks = NULL),
   coord_polar()
  ) %>%
  gf_theme(theme_void()) %>%
  gf_theme(legend.position = "none")
```

### Combining other information.

> We may have additional information about the relative plausibility of each conjecture. This information could arise from knowledge of how the contents of the bag were generated. It could also arise from previous data. Whatever the source, it would help to have a way to combine different sources of information to update the plausibilities. Luckily there is a natural solution: Just multiply the counts. (p. 25)

Here's a quick version of the table in the middle of page 25.

```{r}
Table25 <-
  Table23 %>% 
  rename(`previous counts` = `ways to produce`,
         `ways to produce` = `draw 1: blue`) %>% 
  select(p_1:p_4, `ways to produce`, `previous counts`) %>% 
  mutate(`new count` = `ways to produce` * `previous counts`)

Table25 %>% 
  knitr::kable()
```

We might update to reproduce the table a the top of page 26, like this.

```{r}
Table26 <-
  Table25 %>% 
  select(p_1:p_4, `new count`) %>% 
  rename(`prior count`   = `new count`) %>% 
  mutate(`factory count` = c(0, 3:0)) %>% 
  mutate(`new count`     = `prior count` * `factory count`)

Table26 %>% 
  knitr::kable()
```

To learn more about `dplyr::select()` and `dplyr::rename()`, check out Baert's exhaustive blog post, [*Data wrangling part 1: Basic to advanced ways to select columns*](https://suzan.rbind.io/2018/01/dplyr-tutorial-1/).

#### Rethinking: Original ignorance. 

> Which assumption should we use, when there is no previous information about the conjectures? The most common solution is to assign an equal number of ways that each conjecture could be correct, before seeing any data. This is sometimes known as the **principle of indifference**: When there is no reason to say that one conjecture is more plausible than another, weigh all of the conjectures equally. This book does not use nor endorse "ignorance" priors. As we'll see in later chapters, the structure of the model and the scientific context always provide information that allows us to do better than ignorance. (p. 26, **emphasis** in the original)

### From counts to probability.

The opening sentences in this subsection are important: "It is helpful to think of this strategy as adhering to a principle of honest ignorance: *When we don't know what caused the data, potential causes that may produce the data in more ways are more plausible*" (p. 26, *emphasis* in the original).

We can define our updated plausibility as

<center>

plausibility of ![](pictures/theta_02.png) after seeing ![](pictures/data_02.png)

$\propto$

ways ![](pictures/theta_02.png) can produce ![](pictures/data_02.png)

$\times$

prior plausibility of ![](pictures/theta_02.png).

</center>

In other words,

<center>

plausibility of $p$ after $D_\text{new}$ $\propto$ ways $p$ can produce $D_\text{new} \times$ prior plausibility of $p$.

</center>

But since we have to standardize the results to get them into a probability metric, the full equation is

$$\text{plausibility of } p \text{ after } D_\text{new} = \frac{\text{ ways } p \text{ can produce } D_\text{new} \times \text{ prior plausibility of } p}{\text{sum of the products}}.$$

You might make a version of the table in the middle of page 27 like this.

```{r}
Table26 %>% 
  select(p_1:p_4) %>% 
  mutate(p                      = seq(from = 0, to = 1, by = .25),
         `ways to produce data` = c(0, 3, 8, 9, 0)) %>% 
  mutate(plausibility = `ways to produce data` / sum(`ways to produce data`))
```

We just computed the plausibilities, but here's McElreath's **R** code 2.1.

```{r}
ways <- c(0, 3, 8, 9, 0)

ways / sum(ways)
```

## Building a model

We might save our globe-tossing data in a tibble.

```{r}
(
  Globe <- 
    tibble(toss = c("w", "l", "w", "w", "w", "l", "w", "l", "w"))
)
```

### A data story.

> Bayesian data analysis usually means producing a story for how the data came to be. This story may be *descriptive*, specifying associations that can be used to predict outcomes, given observations. Or it may be *causal*, a theory of how some events produce other events. Typically, any story you intend to be causal may also be descriptive. But many descriptive stories are hard to interpret causally. But all data stories are complete, in the sense that they are sufficient for specifying an algorithm for simulating new data. (p. 28, *emphasis* in the original)

### Bayesian updating.

Here we'll add the cumulative number of trials, `n_trials`, and the cumulative number of successes, `n_successes` (i.e., `toss == "w"`), to the data.

```{r}
(
  Globe <-
    Globe %>% 
    mutate(n_trials  = 1:9,
           n_success = cumsum(toss == "w"))
)
```

Fair warning: We don't learn the skills for making Figure 2.5 until later in the chapter. So consider the data wrangling steps in this section as something of a preview.

```{r, fig.width = 6, fig.height = 5, include = !use_ggformula, eval = !use_ggformula}
sequence_length <- 50

Globe %>% 
  expand(
    nesting(n_trials, toss, n_success), 
    p_water = seq(from = 0, to = 1, length.out = sequence_length)) %>% 
  group_by(p_water) %>% 
 # you can learn more about lagging here:
 # * https://www.rdocumentation.org/packages/stats/versions/3.5.1/topics/lag 
 # * https://dplyr.tidyverse.org/reference/lead-lag.html
  mutate(lagged_n_trials  = lag(n_trials, k = 1),
         lagged_n_success = lag(n_success, k = 1)) %>% 
  ungroup() %>% 
  mutate(prior      = ifelse(n_trials == 1, .5,
                             dbinom(x    = lagged_n_success, 
                                    size = lagged_n_trials, 
                                    prob = p_water)),
         likelihood = dbinom(x    = n_success, 
                             size = n_trials, 
                             prob = p_water),
         strip      = str_c("n = ", n_trials)) %>% 
  # the next three lines allow us to normalize the prior and the likelihood, 
  # putting them both in a probability metric 
  group_by(n_trials) %>% 
  mutate(prior      = prior / sum(prior),
         likelihood = likelihood / sum(likelihood)) %>%   
  
  # plot!
  ggplot(aes(x = p_water)) +
  geom_line(aes(y = prior), 
            linetype = 2) +
  geom_line(aes(y = likelihood)) +
  scale_x_continuous("proportion water", breaks = c(0, .5, 1)) +
  scale_y_continuous("plausibility", breaks = NULL) +
  theme(panel.grid = element_blank()) +
  facet_wrap(~strip, scales = "free_y")
```

```{r, fig.width = 6, fig.height = 5, include = use_ggformula, eval = use_ggformula}
sequence_length <- 50

Globe %>% 
  expand(
    nesting(n_trials, toss, n_success), 
    p_water = seq(from = 0, to = 1, length.out = sequence_length)) %>% 
  group_by(p_water) %>% 
 # you can learn more about lagging at one of these places:
 # * https://www.rdocumentation.org/packages/stats/versions/3.5.1/topics/lag 
 # * https://dplyr.tidyverse.org/reference/lead-lag.html
  mutate(lagged_n_trials  = lag(n_trials, k = 1),
         lagged_n_success = lag(n_success, k = 1)) %>% 
  ungroup() %>% 
  mutate(prior      = ifelse(n_trials == 1, .5,
                             dbinom(x    = lagged_n_success, 
                                    size = lagged_n_trials, 
                                    prob = p_water)),
         likelihood = dbinom(x    = n_success, 
                             size = n_trials, 
                             prob = p_water),
         strip      = str_c("n = ", n_trials)) %>% 
  # the next three lines allow us to normalize the prior and the likelihood, 
  # putting them both in a probability metric 
  group_by(n_trials) %>% 
  mutate(prior      = prior / sum(prior),
         likelihood = likelihood / sum(likelihood)) %>%   
  
  # plot!
  gf_line(prior ~ p_water, linetype = 2) %>%
  gf_line(likelihood ~ p_water) %>%
  gf_facet_wrap( ~ strip, scales = "free_y") %>%
  gf_refine(
    scale_x_continuous("proportion water", breaks = c(0, .5, 1)),
    scale_y_continuous("plausibility", breaks = NULL) 
  ) %>%
  gf_theme(theme_void())
```

If it wasn't clear in the code, the dashed curves are normalized prior densities. The solid ones are normalized likelihoods. If you don't normalize (i.e., divide the density by the sum of the density), their respective heights don't match up with those in the text. Furthermore, itâs the normalization that makes them directly comparable.

To learn more about `dplyr::group_by()` and its opposite `dplyr::ungroup()`, check out [*R4DS*, Chapter 5](http://r4ds.had.co.nz/transform.html). To learn about `tidyr::expand()`, go [here](https://tidyr.tidyverse.org/reference/expand.html).

#### Rethinking: Sample size and reliable inference. 

> It is common to hear that there is a minimum number of observations for a useful statistical estimate. For example, there is a widespread superstition that 30 observations are needed before one can use a Gaussian distribution. Why? In non-Bayesian statistical inference, procedures are often justified by the method's behavior at very large sample sizes, so-called asymptotic behavior. As a result, performance at small samples sizes is questionable.
>
> In contrast, Bayesian estimates are valid for any sample size. This does not mean that more data isn't helpful--it certainly is. Rather, the estimates have a clear and valid interpretation, no matter the sample size. But the price for this power is dependency upon the initial plausibilities, the prior. If the prior is a bad one, then the resulting inference will be misleading. There's no free lunch, when it comes to learning about the world. (p. 31, *emphasis* in the original)

### Evaluate.

> The Bayesian model learns in a way that is demonstrably optimal, provided that it accurately describes the real, large world. This is to say that your Bayesian machine guarantees perfect inference within the small world. No other way of using the available information, beginning with the same state of information, could do better.
>
> Don't get too excited about this logical virtue, however. The calculations may malfunction, so results always have to be checked. And if there are important differences between the model and reality, then there is no logical guarantee of large world performance. And even if the two worlds did match, any particular sample of data could still be misleading. (p. 31)

#### Rethinking: Deflationary statistics.

> It may be that Bayesian inference is the best general purpose method of inference known. However, Bayesian inference is much less powerful than we'd like it to be. There is no approach to inference that provides universal guarantees. No branch of applied mathematics has unfettered access to reality, because math is not discovered, like the proton. Instead it is invented, like the shovel. (p. 32)

This stance brushes up against what is sometimes called *mathematical platonism*, which is a position I suspect is causally held among many scientists and laypersons, alike. For more on the topic, check out *Platonism in the philosophy of mathematics* [@linneboPlatonismPhilosophyMathematics2018].

## Components of the model

We can sum up the components of the model as three things:

1. a likelihood function: "the number of ways each conjecture could produce an observation,"
2. one or more parameters: "the accumulated number of ways each conjecture cold produce the entire data," and 
3. a prior: "the initial plausibility of each conjectured cause of the data" (p. 32).

### Variables.

> Variables are just symbols that can take on different values. In a scientific context, variables include things we wish to infer, such as proportions and rates, as well as things we might observe, the data....
>
> Unobserved variables are usually called **parameters**. (p. 32, **emphasis** in the original)

### Definitions.

> Once we have the variables listed, we then have to define each of them. In defining each, we build a model that relates the variables to one another. Remember, the goal is to count all the ways the data could arise, given the assumptions. (p. 33)

#### Observed variables.

> So that we don't have to literally count, we can use a mathematical function that tells us the right plausibility. In conventional statistics, a distribution function assigned to an observed variable is usually called a **likelihood**. (p. 33, **emphasis** in the original)

If you let the count of water be $w$ and the count of land be $l$, then the binomial likelihood for the globe-tossing data may be expressed as

$$\operatorname{Pr} (w, l| p) = \frac{(w + l)!}{w!l!} p^w (1 - p)^l.$$

As McElreath wrote, we can read that as: "*The counts of 'water' W and 'land' L are distributed binomially, with probability* $p$ *of 'water' on each toss*. (p. 33, *emphasis* in the original). Given a probability of .5, we can use the `dbinom()` function to determine the likelihood of 6 out of 9 tosses coming out water.

```{r}
dbinom(x = 6, size = 9, prob = .5)
```

McElreath suggested we change the values of `prob`. Here is a way to do so over the parameter space, $[0, 1]$.

```{r, fig.width = 3, fig.height = 2, include = !use_ggformula, eval = !use_ggformula}
tibble(prob = seq(from = 0, to = 1, by = .01)) %>% 
  ggplot(aes(x = prob, y = dbinom(x = 6, size = 9, prob = prob))) +
  geom_line() +
  labs(x = "probability",
       y = "binomial likelihood") +
  theme(panel.grid = element_blank())
```

```{r, fig.width = 3, fig.height = 2, include = use_ggformula, eval = use_ggformula}
gf_fun(dbinom(x = 6, size = 9, prob = p) ~ p, xlim = c(0, 1)) %>%
  gf_labs(
    x = "probability",
    y = "binomial likelihood") %>%
  gf_theme(panel.grid = element_blank())
```

##### Overthinking: Names and probability distributions. 

> The "`d`" in `dbinom` stands for *density*. Functions named in this way almost always have corresponding partners that begin with "`r`" for random samples and that begin with "`p`" for cumulative probabilities. See for example the help `?dbinom`. (p. 34, *emphasis* in the original)

#### Unobserved variables.

> The distributions we assign to the observed variables typically have their own variables. In the binomial above, there is $pv, the probability of sampling water. Since $p$ is not observed, we usually call it a **parameter**. Even though we cannot observe $p$, we still have to define it. (p. 34, **emphasis** in the original)

#### Overthinking: Prior as a probability distribution

McElreath said that "for a uniform prior from $a$ to $b$, the probability of any point in the interval is $1 / (b - a)$" (p. 35). Let's try that out. To keep things simple, we'll hold $a$ constant while varying the values for $b$.

```{r}
tibble(
  a = 0,
  b = c(1, 1.5, 2, 3, 9)
) %>% 
  mutate(prob = 1 / (b - a))
```

I like to verify things with plots.

```{r, fig.width = 8, fig.height = 2, include = !use_ggformula, eval = !use_ggformula}
expand_grid(
  a = 0,
  b = c(1, 1.5, 2, 3, 9),
  parameter_space = seq(from = 0, to = 9, length.out = 500)
) %>%
  mutate(
    prob = dunif(parameter_space, a, b),
    b    = str_c("b = ", b)) %>% 
  
  ggplot(aes(x = parameter_space, ymin = 0, ymax = prob)) +
  geom_ribbon() +
  scale_x_continuous(breaks = c(0, 1:3, 9)) +
  scale_y_continuous(breaks = c(0, 1/9, 1/3, 1/2, 2/3, 1),
                     labels = c("0", "1/9", "1/3", "1/2", "2/3", "1")) +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()) +
  facet_wrap(~b, ncol = 5)
```

```{r, fig.width = 8, fig.height = 2, include = use_ggformula, eval = use_ggformula}
gf_dist("unif", min = 0, max = 9, fill = ~"Unif(0, 9)", geom = "area", alpha = 0.3) %>%
  gf_dist("unif", mina = 0, max = 3, fill = ~"Unif(0, 3)", geom = "area", alpha = 0.3) %>%
  gf_dist("unif", mina = 0, max = 2, fill = ~"Unif(0, 2)", geom = "area", alpha = 0.3) %>%
  gf_dist("unif", mina = 0, max = 1, fill = ~"Unif(0, 1)", geom = "area", alpha = 0.3) %>%
  gf_theme(legend.position = "top")
```  


As we'll learn much later in the project, the $\operatorname{Unif}(0, 1)$ distribution is special in that we can also express it as the beta distribution for which $\alpha = 1 \text{ and } \beta = 1$. E.g.,

```{r, fig.width = 2.5, fig.height = 2, include = !use_ggformula, eval = !use_ggformula}
tibble(parameter_space = seq(from = 0, to = 1, length.out = 50)) %>% 
  mutate(prob = dbeta(parameter_space, 1, 1)) %>% 
  
  ggplot(aes(x = parameter_space, ymin = 0, ymax = prob)) +
  geom_ribbon() +
  scale_y_continuous("density", limits = c(0, 2)) +
  ggtitle(expression("This is beta"*(1*", "*1))) +
  theme(panel.grid = element_blank())
```


```{r, fig.width = 2.5, fig.height = 2, include = use_ggformula, eval = use_ggformula}
gf_dist("beta", shape1 = 1, shape2 = 1, geom = "area", alpha = 0.5) %>%
  gf_labs(title = expression("This is beta"*(1*", "*1))) %>%
  gf_lims(y = c(0, 2)) %>%
  gf_theme(panel.grid = element_blank())
```

#### Rethinking: Datum or parameter?

> It is typical to conceive of data and parameters as completely different kinds of entities. Data are measured and known; parameters are unknown and must be estimated from data. Usefully, in the Bayesian framework the distinction between a datum and a parameter is not so fundamental. (p. 35)

For more in this topic, check out McElreath's lecture, [*Understanding Bayesian statistics without frequentist language*](https://www.youtube.com/watch?v=yakg94HyWdE&frags=pl%2Cwn).

### A model is born.

We can now describe our observed variables, $w$ and $l$, with parameters within the binomial likelihood, our shorthand notation for which is

$$w \sim \operatorname{Binom}(n, p),$$

where $n = w + l$. Our binomial likelihood contains a parameter for an unobserved variable, $p$. Parameters in Bayesian models are assigned priors and we can report our prior for $p$ as

$$p \sim \operatorname{Unif}(0, 1),$$

which expresses the model assumption that the entire range of possible values for $p$, $[0, 1]$, are equally plausible. 

## Making the model go

> For every unique combination of data, likelihood, parameters, and prior, there is a unique posterior distribution. This distribution contains the relative plausibility of different parameter values, conditional on the data and model. The *posterior distribution* takes the form of the probability of the parameters, conditional on the data. (p. 36, *emphasis* added)

### Bayes' theorem.

We already know about our values for $w$, $l$, and, by logical necessity, $n$. Bayes' theorem will allow us to determine the plausability of various values of $p$, given $w$ and $l$, which we can express formally as $\operatorname{Pr}(p | w, l)$. Building on some of the earlier equations on page 37, Bayes' theorem tells us that

$$\operatorname{Pr}(p | w, l) = \frac{\operatorname{Pr}(w, l | p) \operatorname{Pr}(p )}{\operatorname{Pr}(w, l)}.$$

> And this is Bayes' theorem. It says that the probability of any particular value of $p$, considering the data, is equal to the product of the relative plausibility of the data, conditional on $p$, and the prior plausibility of $p$, divided by this thing $\operatorname{Pr}(W, L)$, which Iâll call the *average probability of the data*. (p. 37, *emphasis* in the original) 

We can express this in words as

$$\text{Posterior} = \frac{\text{Probability of the data} \times \text{Prior}}{\text{Average probability of the data}}.$$

The average probability of the data is often called the "evidence" or the "average likelihood" and we'll get a sense of what that means as we go along. "The key lesson is that the posterior is proportional to the product of the prior and the probability of the data" (p. 37). Figure 2.6 will help us see what this means. Here are the preparatory steps for the data.

```{r}
sequence_length <- 1e3

Fig2.6 <-
  expand_grid(
    prior_name = c("flat", "stepped", "Laplace"),
    probability = seq(from = 0, to = 1, length.out = sequence_length)
  ) %>%
  mutate(
    prior = 
      case_when(
        prior_name == "flat"    ~  1,
        prior_name == "stepped" ~ (probability >= 0.5) * 1,
        prior_name == "Laplace" ~ exp(-abs(probability - 0.5) / .25) / ( 2 * 0.25)),
    likelihood = dbinom(x = 6, size = 9, prob = probability)) %>% 
  group_by(prior_name) %>% 
  mutate(posterior = prior * likelihood / sum(prior * likelihood)) %>% 
  pivot_longer(prior:posterior)  %>% 
  ungroup() %>% 
  mutate(
    name = factor(name, levels = c("prior", "likelihood", "posterior")),
    prior_name = factor(prior_name, levels = c("flat", "stepped", "Laplace"))
  )
```

To learn more about `dplyr::arrange()`, chech out [*R4DS*, Chapter 5.3](http://r4ds.had.co.nz/transform.html#arrange-rows-with-arrange).

In order to avoid unnecessary facet labels for the rows, it was easier to just make each column of the plot separately. We can then use the elegant and powerful syntax from [Thomas Lin Pedersen](https://twitter.com/thomasp85)'s [-@R-patchwork] [**patchwork** package](https://patchwork.data-imaginist.com/) to combine them.

```{r, fig.width = 6, fig.height = 5, warning = F, message = F, include = !use_ggformula, eval = !use_ggformula}
p1 <-
  Fig2.6 %>%
  filter(prior_name == "flat") %>% 
  ggplot(aes(x = probability, y = value)) +
  geom_line() +
  scale_x_continuous(NULL, breaks = NULL) +
  scale_y_continuous(NULL, breaks = NULL) +
  theme(panel.grid = element_blank()) +
  facet_wrap(~name, scales = "free_y")

p2 <-
  Fig2.6 %>%
  filter(prior_name == "stepped") %>% 
  ggplot(aes(x = probability, y = value)) +
  geom_line() +
  scale_x_continuous(NULL, breaks = NULL) +
  scale_y_continuous(NULL, breaks = NULL) +
  theme(panel.grid = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank()) +
  facet_wrap(~name, scales = "free_y")

p3 <-
  Fig2.6 %>%
  filter(prior_name == "Laplace") %>% 
  ggplot(aes(x = probability, y = value)) +
  geom_line() +
  scale_x_continuous(NULL, breaks = c(0, .5, 1)) +
  scale_y_continuous(NULL, breaks = NULL) +
  theme(panel.grid = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank()) +
  facet_wrap(~name, scales = "free_y")

library(patchwork)

p1 / p2 / p3
```

```{r, fig.width = 6, fig.height = 5, warning = F, message = F, include = use_ggformula, eval = use_ggformula}
Fig2.6 %>% 
  gf_line(value ~ probability) %>%
  gf_facet_wrap( prior_name ~ name, scales = "free_y") %>%
  gf_refine(
    scale_y_continuous(NULL, breaks = NULL) 
  ) %>%
  gf_theme(panel.grid = element_blank())
```

```{r, fig.width = 6, fig.height = 5, warning = F, message = F, include = FALSE && use_ggformula, eval = use_ggformula}
p1 <-
  Fig2.6 %>% filter(prior_name == "flat") %>%
  gf_line(value ~ probability) %>%
  gf_facet_wrap( ~ name, scales = "free") %>%
  gf_theme(panel.grid = element_blank())

p2 <-
  Fig2.6 %>% filter(prior_name == "stepped") %>%
  gf_line(value ~ probability) %>%
  gf_facet_wrap( ~ name, scales = "free") %>%
  gf_theme(panel.grid = element_blank())

p3 <-
  Fig2.6 %>% filter(prior_name == "Laplace") %>%
  gf_line(value ~ probability) %>%
  gf_facet_wrap( ~ name, scales = "free") %>%
  gf_theme(panel.grid = element_blank())

library(patchwork)
p1 / p2 / p3
```

I'm not sure if it's the same McElreath used in the text, but the formula I used for the triangle-shaped prior is the [Laplace distribution](https://rdrr.io/cran/rmutil/man/Laplace.html) with a location of 0.5 and a dispersion of 0.25.

Also, to learn all about `dplyr::filter()`, check out Baert's [*Data wrangling part 3: Basic and more advanced ways to filter rows*](https://suzan.rbind.io/2018/02/dplyr-tutorial-3/).

### Motors.

> Various numerical techniques are needed to approximate the mathematics that follows from the definition of Bayes' theorem. In this book, you'll meet three different conditioning engines, numerical techniques for computing posterior distributions:
>
> 1. Grid approximation
> 2. Quadratic approximation
> 3. Markov chain Monte Carlo (MCMC)
>
> There are many other engines, and new ones are being invented all the time. But the three you'll get to know here are common and widely useful. (p. 39)

`r emo::ji("warning")` In this translation of McElreath's text, we will get a little practice with grid approximation and the quadratic approximation. But since our aim is to practice with **brms**, we'll jump rather quickly into MCMC. This will be awkward at times because it will force us to contend with technical issues in earlier problems in the text than McElreath originally did. I'll do what I can to bridge the pedagogical gaps.

### Grid approximation.

Continuing on with our globe-tossing example,

> at any particular value of a parameter, $p'$ , it's a simple matter to compute the posterior probability: just multiply the prior probability of $p'$ by the likelihood at $p'$. Repeating this procedure for each value in the grid generates an approximate picture of the exact posterior distribution. This procedure is called **grid approximation**. (pp. 39--40, **emphasis** in the original)

We just employed grid approximation over the last figure. To get nice smooth
lines, we computed the posterior over 1,000 evenly-spaced points on the
probability space. Here we'll prepare for Figure 2.7 with 20 equally-spaced points.

We do this using two important functions:

* `expand_grid()` creates a data frame with every combination of the vectors it is provided.

    In the example below, since we only have one parameter, we could have used `tibble()` instead.
    But for models with multiple parameters, we will want to use `expand_grid()` so that we 
    get every *combination*.
    
* `mutatate()` adds new columns to a data frame -- often computed using values in existing columns.

It's a good idea to do a little **sanity checking** after building a data frame like this. In a simple
case, just inspecting a few rows may suffice. In more complicated examples, we may want to compute
some numerical or graphical summaries. Sanity checking doesn't guarantee that everything is correct
but tries to make sure things are not horribly and obviously wrong.

```{r}
Grid20 <-
  expand_grid(
    p = seq(from = 0, to = 1, length.out = 20)            # define grid
  ) %>%
  mutate(
    prior  = 1,                                           # define prior
    likelihood = dbinom(6, size = 9, prob = p),           # compute likelihood at each value in grid
    unstd_posterior = likelihood * prior,                 # compute product of likelihood and prior
    posterior = unstd_posterior / sum(unstd_posterior)    # standardize the posterior, so it sums to 1
  )
Grid20
```

Here's the code for the right panel of Figure 2.7.

```{r include = !use_ggformula, eval = !use_ggformula}
p1 <-
  Grid20 %>% 
  ggplot(aes(x = p, y = posterior)) +
  geom_point() +
  geom_line() +
  labs(subtitle = "20 points",
       x = "probability of water",
       y = "posterior probability") +
  theme(panel.grid = element_blank())
```

```{r include = use_ggformula, eval = use_ggformula}
p1 <-
  Grid20 %>% 
  gf_line(posterior ~ p) %>%
  gf_point() %>%
  gf_labs(subtitle = "20 points",
       x = "probability of water",
       y = "posterior probability") %>%
  gf_theme(panel.grid = element_blank())
```


Now here's the code for the left hand panel of Figure 2.7.

```{r}
Grid5 <-
  expand_grid(
    p = seq(from = 0, to = 1, length.out = 5)            # 1-parameter grid
  ) %>% 
  mutate(
    prior  = 1,                                          # define prior
    likelihood = dbinom(6, size = 9, prob = p),          # compute likelihood at each value in grid
    unstd_posterior = likelihood * prior,                # compute product of likelihood and prior
    posterior = unstd_posterior / sum(unstd_posterior)   # standardize the posterior, so it sums to 1
  )
```

```{r include = !use_ggformula, eval = !use_ggformula}
p2 <-
  Grid5 %>%
  
  ggplot(aes(x = p, y = posterior)) +
  geom_point() +
  geom_line() +
  labs(subtitle = "5 points",
       x = "probability of water",
       y = "posterior probability") +
  theme(panel.grid = element_blank())
```

```{r include = use_ggformula, eval = use_ggformula}
p2 <-
  Grid5 %>%
  gf_line(posterior ~ p) %>%
  gf_point() %>%
  gf_labs(subtitle = "5 points",
       x = "probability of water",
       y = "posterior probability") %>%
  gf_theme(panel.grid = element_blank())
```

Here we combine them and plot!

```{r, fig.width = 6, fig.height = 3}
p2 + p1 + plot_annotation(title = "More grid points make for smoother approximations")
```

In his **R** code 2.5 box, McElreath encouraged us to redo those plots with the two new kinds of priors.

```{r, eval = F}
prior <- ifelse( p < 0.5 , 0 , 1 ) 
prior <- exp( -5 * abs( p - 0.5 ) )
```

That first prior can also be coded as

```{r, eval = FALSE}
prior <- (p < 0.5) * 1
```

The logical is turned into 0 or 1 when multiplied by 1.

Here's a condensed way to make the four plots all at once. Things to notice:

* We have added a label for the prior to `expand_grid()` so after that step we have 4 rows in our data.
* The first `mutate()` adds a new column.  This column contains a list of either 5 or 20 points.
* `unnest()` fulls apart those lists make 5 or 20 rows.
* At this point we are ready to proced with our usual `mutate()` step to add prior, likelihood, and 
posterior.

```{r, fig.width = 6, fig.height = 5}
# make the data
Grids <-
  expand_grid(
    n_points = c(5, 20),
    prior_label = c("ifelse(p < 0.5, 0, 1)", "exp(-5 * abs(p - 0.5))")
    ) %>% 
  mutate(p = map(n_points, ~ seq(from = 0, to = 1, length.out = .))) %>% 
  unnest(p) %>% 
  mutate(
    prior = 
      ifelse(prior_label == "ifelse(p < 0.5, 0, 1)", 
             ifelse(p < 0.5, 0, 1),
             exp(-5 * abs(p - 0.5))),
    likelihood = dbinom(6, size = 9, prob = p),
    posterior = likelihood * prior / sum(likelihood * prior),
    n_points = str_c("# points = ", n_points),
    priors   = str_c("prior = ", prior_label)) 

Grids %>%
  group_by(prior_label, n_points) %>% tally()
```

```{r include = !use_ggformula, eval = !use_ggformula}
Grids %>%
  ggplot(aes(x = p, y = posterior)) +
  geom_line() +
  geom_point() +
  labs(
       x = "probability of water",
       y = "posterior probability") +
  theme(panel.grid = element_blank()) +
  facet_grid(n_points ~ prior_label, scales = "free")
```

```{r include = use_ggformula, eval = use_ggformula}
Grids %>%
  gf_line(posterior ~ p) %>%
  gf_point() %>% 
  gf_facet_grid(n_points ~ prior_label, scales = "free") %>%
  gf_labs(
    x = "probability of water",
    y = "posterior probability") %>% 
  gf_theme(panel.grid = element_blank())  
```

### Quadratic approximation.

> Under quite general conditions, the region near the peak of the posterior distribution will be nearly Gaussian--or "normal"--in shape. This means the posterior distribution can be usefully approximated by a Gaussian distribution. A Gaussian distribution is convenient, because it can be completely described by only two numbers: the location of its center (mean) and its spread (variance).
>
> A Gaussian approximation is called "*quadratic approximation*" because the logarithm of a Gaussian distribution forms a parabola. And a parabola is a quadratic function. So this approximation essentially represents any log-posterior with a parabola. (p. 42, *emphasis* added)

Though McElreath will use the quadratic approximation for the first half of the text, we won't use it much past this chapter. Here, though, we'll apply the quadratic approximation to the globe tossing data with the `rethinking::quap()` function.

```{r, warning = F, message = F}
library(rethinking)

globe_qa <- quap(
  alist(
    W ~ dbinom(W + L, p),  # binomial likelihood 
    p ~ dunif(0, 1)        # uniform prior
  ), 
  data = list(W = 6, L = 3)
)

# display summary of quadratic approximation 
precis(globe_qa)
```

In preparation for Figure 2.8, here's the model with $n = 18$ and $n = 36$.

```{r}
globe_qa_18 <-
  quap(
    alist(
      w ~ dbinom(9 * 2, p),
      p ~ dunif(0, 1)
    ), data = list(w = 6 * 2))

globe_qa_36 <-
  quap(
    alist(
      w ~ dbinom(9 * 4, p),
      p ~ dunif(0, 1)
    ), data = list(w = 6 * 4))

precis(globe_qa_18)
precis(globe_qa_36)
```

Now make Figure 2.8.

```{r, fig.width = 8, fig.height = 2.75}
n_grid <- 100

Grid <-
  tibble(
    w = c(6, 12, 24),
    n = c(9, 18, 36),
    s = c(.16, .11, .08)) %>% 
  expand(
    nesting(w, n, s),
    p = seq(from = 0, to = 1, length.out = n_grid)) %>% 
  mutate(
    prior = 1,
    m     = .67,  
    likelihood = dbinom(w, size = n, prob = p), 
    unstd_grid_posterior = likelihood * prior,
    unstd_quad_posterior = dnorm(p, m, s)) %>%
  group_by(w) %>% 
  mutate(
    grid_posterior = unstd_grid_posterior / sum(unstd_grid_posterior),
    quad_posterior = unstd_quad_posterior / sum(unstd_quad_posterior),
    n              = reorder(str_c("n = ", n), n))

Grid %>%                 # sanity check; make sure we have the number of rows we expect.
  group_by(w, n, s) %>% 
  summarise(rows = n())
```

A new function is introduced here: `expand()`.  This works something like `grid_expand()`.

* The first input is a data frame rather than vectors. Our initial use of
`tibble()` is building that input.

* We have some finer control over how the expansion happens.  In this case,
`nesting(w, n, s)` doesn't talk all combinations of those values, only the ones
that appear in the data frame. (It's really make a new column with all three values combined.)

* Each of these combinations of `w`, `n`, and `s` is paired with each value of `p`, just like
when using `expand_grid()`.

```{r include = ! use_ggformula, eval = ! use_ggformula}
Grid %>% 
  gf_line(grid_posterior ~ p, color = ~ "grid") %>%
  gf_line(quad_posterior ~ p, color = ~ "quad") %>%
  gf_labs(
    x = "proportion water (p)",
    y = "density",
    colour = "method") %>% 
  gf_facet_wrap(~n, scales = "free") %>%
  gf_labs(x = "proportion water (p)", y = "density", color = "method") %>% 
  gf_theme(panel.grid = element_blank(), legend.position = "top") 
```

```{r include = use_ggformula, eval = use_ggformula}
Grid %>% 
  ggplot(aes(x = p)) +
  geom_line(aes(y = grid_posterior)) +
  geom_line(aes(y = quad_posterior),
            color = "grey50") +
  theme(panel.grid = element_blank(), legend.position = "top") +
  facet_wrap(~n, scales = "free")
```

> This phenomenon, where the quadratic approximation improves with the amount of data, is very common. It's one of the reasons that so many classical statistical procedures are nervous about small samples: Those procedures use quadratic (or other) approximations that are only known to be safe with infinite data. Often, these approximations are useful with less than infinite data, obviously. But the rate of improvement as sample size increases varies greatly depending upon the details. In some models, the quadratic approximation can remain terrible even with thousands of samples. (p. 44)

#### Rethinking: Maximum likelihood estimation. 

> The quadratic approximation, either with a uniform prior or with a lot of data, is often equivalent to a **maximum likelihood estimate** (MLE) and its **standard error**. The MLE is a very common non-Bayesian parameter estimate. This correspondence between a Bayesian approximation and a common non-Bayesian estimator is both a blessing and a curse. It is a blessing, because it allows us to re-interpret a wide range of published non-Bayesian model fits in Bayesian terms. It is a curse, because maximum likelihood estimates have some curious drawbacks, and the quadratic approximation can share them. (p. 44, **emphasis**, in the original)

Textbooks highlighting the maximum likelihood method for the generalized linear model abound. If this is new to you and you'd like to learn more, perhaps check out Linger and Roback's [-@leglerBroadeningYourStatistical2019] [*Broadening your statistical horizons: Generalized linear models and multilevel models*](https://bookdown.org/roback/bookdown-bysh/), Agresti's [-@agrestiFoundationsLinearGeneralized2015] [*Foundations of linear and generalized linear models*](https://www.wiley.com/en-us/Foundations+of+Linear+and+Generalized+Linear+Models-p-9781118730034) or Dunn and Smyth's [-@dunn2018generalized] [*Generalized linear models with examples in R*](https://link.springer.com/book/10.1007/978-1-4419-0118-7).

### Markov chain Monte Carlo.

> The most popular [alternative to grid approximation and the quadratic approximation] is **Markov chain Monte Carlo** (MCMC), which is a family of conditioning engines capable of handling highly complex models. It is fair to say that MCMC is largely responsible for the insurgence of Bayesian data analysis that began in the 1990s. While MCMC is older than the 1990s, affordable computer power is not, so we must also thank the engineers. ~~Much later in the book (Chapter 9)~~, you'll meet simple and precise examples of MCMC model fitting, aimed at helping you understand the technique. (p. 45, **emphasis** in the original)

The **brms** package uses a version of MCMC to fit Bayesian models. Since one of the main goals of this project is to highlight **brms**, we may as fit a model. This seems like an appropriately named subsection to do so. First we'll have to load the package.

```{r, warning = F, message = F}
library(brms)
```

If you haven't already installed **brms**, you can find instructions on how to do so [here](https://github.com/paul-buerkner/brms#how-do-i-install-brms).

Here we re-fit the last model from above, the one for which $w = 24$ and $n = 36$.

```{r b2.1}
library(brms)
b2.1 <-
  brm(data = list(w = 24), 
      family = binomial(link = "identity"),
      w | trials(36) ~ 0 + Intercept,
      prior(beta(1, 1), class = b, lb = 0, ub = 1),
      seed = 2,
      file = "fits/b02.01")
```

The model output from **brms** looks like so.

```{r}
b2.1
```

There's a lot going on in that output, which we'll start to clarify in [Chapter 4][Geocentric Models]. For now, focus on the 'Intercept' line. As we'll also learn in Chapter 4, the intercept of a regression model with no predictors is the same as its mean. In the special case of a model using the binomial likelihood, the mean is the probability of a 1 in a given trial, $\theta$.
 
Also, with **brms**, there are many ways to summarize the results of a model.
The `brms::posterior_summary()` function is an analogue to
`rethinking::precis()`. We will, however, want to round to a reasonable number of digits.
This can be done using `round()`.  
To tell R how many digits you usually want, try `options(digits = 3)`.

```{r}
posterior_summary(b2.1)  %>% 
  round(digits = 3)
```

The `b_Intercept` row is the probability. Don't worry about the second line, for now. We'll cover the details of **brms** model fitting in later chapters. To finish up, why not plot the results of our model and compare them with those from `rethinking::quap()`, above?

```{r, fig.width = 3, fig.height = 2.75, include = ! use_ggformula, eval = ! use_ggformula}
posterior_samples(b2.1) %>% 
  mutate(n = "n = 36") %>%
  ggplot(aes(x = b_Intercept)) +
  geom_density(fill = "black") +
  scale_x_continuous("proportion water", limits = c(0, 1)) +
  theme(panel.grid = element_blank()) +
  facet_wrap(~n)
```

```{r, fig.width = 3, fig.height = 2.75, include = ! use_ggformula, eval = ! use_ggformula}
posterior_samples(b2.1) %>% 
  mutate(n = "n = 36") %>%
  gf_density( ~ b_Intercept | n) %>%
  gf_lims(x = c(0, 1)) %>%
  gf_labs(x = "proportion water (p)") %>%
  gf_theme(panel.grid = element_blank()) 
```

If you're still confused. Cool. This is just a preview. We'll start walking through fitting models with **brms** in [Chapter 4][Geocentric models] and we'll learn a lot about regression with the binomial likelihood in [Chapter 11][God Spiked the Integers].

## Session info {-}

```{r}
sessionInfo()
```

```{r, echo = F, warning = F, message = F}
rm(d, Lines_1, Lines_2, n_blue, n_white, t, move_over, ways, sequence_length, p1, p2, p3, globe_qa, globe_qa_18, globe_qa_36, n_grid, b2.1)
```

```{r, echo = F, warning = F, message = F, results = "hide"}
# pacman::p_unload(pacman::p_loaded(), character.only = TRUE)
```
